{"data":{"markdownRemark":{"html":"<p><a href=\"https://github.com/shipitjs/shipit\" title=\"Shipit - An automation engine and deployment tool written for NodeJS\" target=\"_blank\">Shipit</a> is... awesome.</p>\n<p>Really, though. I've found this to be a fantastic tool for managing my release process. Albeit I'm only using this for my personal website at this time, I can see how I'd use this for continuously deploying at my day job. Over there we use Capistrano, and there's many parallels between the two. Let's start by looking at how it works, and then we'll compare.</p>\n<h2>How it works</h2>\n<p>Chances are you're familiar with <a href=\"https://github.com/gruntjs/grunt\" title=\"Grunt: The JavaScript Task Runner\" target=\"_blank\">grunt</a> or <a href=\"https://github.com/gulpjs/gulp\" title=\"Gulp.js - The streaming build system\">gulp</a>. Aside from them both being build task managers, they both are common in that they have a file that you use to define the tasks, a <code class=\"language-text\">gruntfile</code> or a <code class=\"language-text\">gulpfile</code>, respectively. When a task is ran, the file is located and the referenced task becomes executed. Shipit works the same way with a <code class=\"language-text\">shipitfile</code> and a command line interface.</p>\n<p>First, make sure you have <code class=\"language-text\">shipit</code> installed</p>\n<p>{% highlight sh %}\nnpm install -g shipit-cli\n{% endhighlight %}</p>\n<p>And once we get to the <code class=\"language-text\">shipitfile</code>, you'll be able to run deployments as you would run a build with <code class=\"language-text\">grunt</code> or <code class=\"language-text\">gulp</code>.</p>\n<p>{% highlight sh %}\nshipit production deploy\n{% endhighlight %}</p>\n<p>This command is made up of three things:</p>\n<ol>\n<li><code class=\"language-text\">shipit</code> -- the executable</li>\n<li><code class=\"language-text\">production</code> -- the environment</li>\n<li><code class=\"language-text\">deploy</code> -- the task</li>\n</ol>\n<h2>Shipitfile</h2>\n<p>The first thing you're going to do is create a file called <code class=\"language-text\">shipitfile.js</code>. Let's look to the simple example from the <a href=\"https://github.com/shipitjs/shipit\" title=\"Automation engine and deployment tool\">readme</a>.</p>\n<p>{% highlight javascript %}\nmodule.exports = function (shipit) {\nshipit.initConfig({\nstaging: {\nservers: 'myproject.com'\n}\n});</p>\n<p>  shipit.task('pwd', function () {\nreturn shipit.remote('pwd');\n});\n};\n{% endhighlight %}</p>\n<p>This, again, is pretty similar to <em>both</em> <code class=\"language-text\">grunt</code> and <code class=\"language-text\">gulp</code>.</p>\n<h3>Grunt similarities</h3>\n<p>It's similar to grunt because we declaratively create a configuration for the environment. Just like <code class=\"language-text\">grunt</code>, we can define multiple configuration modes in addition to a set of defaults.</p>\n<p>{% highlight javascript %}\nshipit.initConfig({\ndefault: {\nfoo: 'bar',\nhello: 'world'\n},\nstaging: {\nfoo: 'BAR'\n},\nproduction: {\nhello: 'WORLD'\n}\n});\n{% endhighlight %}</p>\n<p>You get the gist. If we were to run <code class=\"language-text\">shipit staging XYZ</code>, it's going to use the staging configuration rules first, and then the default to default to the rest of the configuration. If we were to run <code class=\"language-text\">shipit production XYZ</code>, same idea -- it'll use the production configuration followed by coalescing with the default configuration.</p>\n<h3>Gulp similarities</h3>\n<p>It's similar to gulp because we functionally compose our tasks.</p>\n<p>{% highlight javascript %}\nshipit.task('createFile', function () {\nreturn shipit.remote('touch helloworld.txt');\n});</p>\n<p>shipit.task('writeFile', function () {\nreturn shipit.remote('echo \"hello, world!\" > helloworld.txt');\n});\n{% endhighlight %}</p>\n<p>These will run just like how you might run a gulp task -- <code class=\"language-text\">shipit production createFile</code> and <code class=\"language-text\">shipit production writeFile</code>.</p>\n<p>And, you may have guessed it, yes, you can define dependency tasks for other tasks like so:</p>\n<p>{% highlight javascript %}\n// createFile will run as a dependency before <code class=\"language-text\">writeFile</code> executes\nshipit.task('writeFile', ['createFile'], function () {\nreturn shipit.remote('echo \"hello, world!\" > helloworld.txt');\n});\n{% endhighlight %}</p>\n<p>Why is this so familiar? They both use <a href=\"https://github.com/orchestrator/orchestrator\" title=\"A module for sequencing and executing tasks and dependencies in maximum concurrency\" target=\"_blank\">Orchestrator</a> for sequencing and executing their tasks. So whatever you're familiar with in <code class=\"language-text\">gulp</code>, you'll feel at home here with <code class=\"language-text\">shipit</code>.</p>\n<p>You can think of this almost like a <code class=\"language-text\">gulp</code> file for your server deployments.</p>\n<h2>Deploying releases with <a href=\"https://github.com/shipitjs/shipit-deploy\" title=\"Shipit - An automation engine and deployment tool written for NodeJS\" target=\"_blank\">shipit-deploy</a></h2>\n<p>Shipit, on its own, is not a fully integrated release manager. It is an underlying set of organized tools to facilitate with executing remote commands and performing <code class=\"language-text\">rsync</code> to deploy files, but out of the box it is not a release manager.</p>\n<p>To take advantage of continuous releases with Shipit comes <a href=\"https://github.com/shipitjs/shipit-deploy\" title=\"Set of deplyment tasks for Shipit based on git and rsync commands\" target=\"_blank\">shipit-deploy</a>. This can be thought of as a predefined set of tasks that take care of building and churning a set of releases. This is where things start to get similar to Capistrano.</p>\n<p>First, let's take a look at the <code class=\"language-text\">shipitfile</code> that <code class=\"language-text\">shipit-deploy</code> provides as an example in their <a href=\"https://github.com/shipitjs/shipit-deploy/blob/master/README.md\" title=\"Shipit README\" target=\"_blank\">readme</a>.</p>\n<p>{% highlight javascript %}\nmodule.exports = function (shipit) {\nrequire('shipit-deploy')(shipit);</p>\n<p>  shipit.initConfig({\ndefault: {\nworkspace: '/tmp/github-monitor',\ndeployTo: '/tmp/deploy<em>to',\nrepositoryUrl: '<a href=\"https://github.com/user/repo.git&#x27;\">https://github.com/user/repo.git'</a>,\nignores: ['.git', 'node</em>modules'],\nkeepReleases: 2,\ndeleteOnRollback: false,\nkey: '/path/to/key',\nshallowClone: true\n},\nstaging: {\nservers: 'user@my-staging-server.com'\n},\nproduction: {\nservers: 'user@my-production-server.com'\n}\n});\n};\n{% endhighlight %}</p>\n<p>That's it. Really. There's nothing more that you have to do than specify your repository, the path on the server you want to deploy to, and the server itself. If you have a well prepared environment, such as having configurations in <code class=\"language-text\">~/.ssh/config</code>, then you don't even need to specify the <code class=\"language-text\">key</code> location or the ssh username. Let's look at what each property does starting with the most important pieces.</p>\n<h4><code class=\"language-text\">deployTo</code></h4>\n<p>This is the remote path on your server where you want your releases to live. It <strong>will not be your servable directory</strong>. We'll get to the directory structure that gets generated below.</p>\n<h4><code class=\"language-text\">repositoryUrl</code></h4>\n<p>You're likely deploying from version control. This would specify where that lives.</p>\n<h4><code class=\"language-text\">staging.servers</code>, <code class=\"language-text\">production.servers</code>, etc</h4>\n<p>First, this is plural because this can be a collection. This is useful if you have multiple instances of your application behind a load balancer. This is the hostname of that(those) box(es).</p>\n<h4><code class=\"language-text\">key</code></h4>\n<p>This is the path to your private key file. I'd suggest leaving this up to <code class=\"language-text\">~/.ssh/config</code> so that your deployment can be flexible and agnostic to the environment its run on. If you use CircleCI, it will automatically configure a hostname when you set up private SSH keys.</p>\n<hr>\n<p>Onto the less important configuration details</p>\n<h4><code class=\"language-text\">workspace</code></h4>\n<p>This is not very significant, and it should probably live in <code class=\"language-text\">/tmp</code> so it will certainly become removed when your reboot. This is simply the \"workspace\" where <code class=\"language-text\">shipit</code> will deal with fetching and preparing files to sync remotely.</p>\n<h4><code class=\"language-text\">ignores</code></h4>\n<p>This is a collection of paths, and I believe expressions, that you want your deployment to exclude</p>\n<h4><code class=\"language-text\">keepReleases</code></h4>\n<p>You can specify how many historical releases you want to to live on your server. We'll go into detail about how this is set up below, but the gist is that you'll want atleast a few that you can rollback to.</p>\n<h4><code class=\"language-text\">deleteOnRollback</code></h4>\n<p>This is pretty self explanatory -- if you rollback a release, do you want it to also become deleted?</p>\n<h4><code class=\"language-text\">shallowClone</code></h4>\n<p>Most of the time this will be <code class=\"language-text\">true</code>. This simply refers to the <a href=\"https://git-scm.com/docs/git-clone\">depth of the <code class=\"language-text\">git clone</code></a>. Typically for builds you're going to be deploying the <code class=\"language-text\">HEAD</code> commit and you won't really need any history of revisions.</p>\n<p>You can find the whole set of options <a href=\"https://github.com/shipitjs/shipit-deploy/blob/master/README.md#options\" title=\"Shipit README options\" target=\"_blank\">here</a>.</p>\n<h2>Release structure</h2>\n<p>As hinted above, your deployment is not simply a set of files that gets thrown up a directory served by your webserver. This is where things get very similar to <a href=\"http://capistranorb.com/documentation/getting-started/structure/\" title=\"Capistrano release structure\" target=\"_blank\">Capistrano's structure</a>. Your deployment safely creates a release directory sibling to previous release directories, and simply rotates a symbolic link used by your webserver which points to the latest release. This makes for zero downtime, and it allows you to rotate -- forward or backward.</p>\n<img src=\"/dist/images/blog/shipit/release-structure.png\" alt=\"Shipit release structure\" />\n<h3>Serving the right directory</h3>\n<p>Shipit is going to create a symlink to the latest release, or the latest rollback, named <code class=\"language-text\">current/</code>.</p>\n<p>If your <code class=\"language-text\">deployTo</code> path is <code class=\"language-text\">/www/application</code>, then your latest release will always live in <code class=\"language-text\">/www/application/current</code>. If you serve your application from the root of the project, then <code class=\"language-text\">current/</code> is where you're going to want to point it. If, say, you serve it out of a subdirectory, <code class=\"language-text\">public/</code>, then <code class=\"language-text\">/www/application/current/public</code> is where you'll be serving from</p>\n<h3>Releases</h3>\n<p>As seen in the release structure there is a directory of <code class=\"language-text\">releases/</code> with many sibling releases of directories named with timestamps. The <code class=\"language-text\">current/</code> is always pointing to the latest release, or the latest rollback. Depending on what you set for <code class=\"language-text\">keepReleases</code>, that will be the number of releases that are kept. As you can assume, Shipit uses a FIFO approach to keep rotating the oldest releases off of your server.</p>\n<p>As to clear up any misunderstanding, if we were to look in one of these directories, you'll find your deployed application.</p>\n<img src=\"/dist/images/blog/shipit/release-content.png\" alt=\"Shipit release content\" />\n<h2>Real world examples</h2>\n<p>If you'd like to see how I used Shipit with CircleCI and Jekyll to deploy this website, you can read me other post about <a href=\"/blog/continuous-deployment-jekyll-circleci-shipit\" title=\"Continuously deploying Jekyll with CircleCI and ShipIt\">continuously deploying Jekyll with Shipit</a>, or simply take a look at <a href=\"https://github.com/ajwhite/jekyll-portfolio\" title=\"Github repository of atticuswhite.com\">the repository</a>.</p>","frontmatter":{"date":"2015-11-04 08:00:00","permalink":"/blog/shipit","title":"Exploring ShipIt"}}},"pageContext":{}}