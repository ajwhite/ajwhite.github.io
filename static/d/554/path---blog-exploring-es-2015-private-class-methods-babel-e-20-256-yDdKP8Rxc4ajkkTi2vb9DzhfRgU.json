{"data":{"markdownRemark":{"html":"<p>Method visibility is not supported by Javascript. There is no way to define a method on a class to be public or private. However we can make use of the <a href=\"http://babeljs.io/blog/2015/05/14/function-bind/\" target=\"_blank\" title=\"ES7 Function Bind\">Function bind syntax</a> to emulate this behavior.</p>\n<h2>ES5 private functions</h2>\n<p>In ES5 we can take advantage of scope to wrap a block of context and only expose a public set of functions, tucking away private information in the scope that the public methods can access. In the example below, we'll have a \"counter\" which will have a private method to log the updated count, and a set of public mutator methods.</p>\n<p>{% highlight javascript %}\nvar MyClass = (function MyClass () {\n// private\nvar count = 0;</p>\n<p>  function somePrivateMethod () {\nconsole.log('count updated', count);\n}</p>\n<p>  // public\nreturn {\nadd: function () {\ncount++;\nsomePrivateMethod()\n},\nsubtract: function () {\ncount--;\nsomePrivateMethod();\n},\ngetCount() {\nreturn count;\n}\n};\n})();\n{% endhighlight %}</p>\n<h2>ES7 private functions</h2>\n<p>ES2015 classes actually throw a bit of a wrench in this approach. We lose the concept of scope in a <code>class</code>. We don't have a block that we can wrap private information and choose which information to make public. We only have a class structure to deal with.</p>\n<p>{% highlight javascript %}\nclass Counter() {\nconstructor() {\nthis.count = 0;\n},\nadd() {\nthis.count++;\nthis.somePrivateMethod();\n}\nsubtract() {\nthis.count--;\nthis.somePrivateMethod();\n}\ngetCount() {\nreturn this.count\n}\nsomePrivateMethod() {\n// not actually private\nconsole.log('count updated', count);\n}\n}\n{% endhighlight %}</p>\n<p>Any method on the class is accessible from the outside - our private method is unfortunately forced into the public domain with the rest of the class.</p>\n<h3>Dumb private functions</h3>\n<p>We could take out the method from the class, place it outside, and call it by passing the <code>count</code>. The downside is that we turn this into a \"dumb\" function that requires passing in the context, rather than the private function being aware of the context. For example:</p>\n<p>{% highlight javascript %}\nfunction somePrivateMethod(count) {\nconsole.log('count updated', count);\n}\nclass Counter {\n//...\nadd() {\nthis.count++;\nsomePrivateMethod(this.count);\n}\n//...\n}\n{% endhighlight %}</p>\n<h3>Function-Bind</h3>\n<p>With function-bind, <code>::</code>, we can <em>bind</em> the context of the class instance to a function. Rather than passing in the pieces the function has to be made aware of, we can provide it with the entire <code>this</code> context, as if it another method on the class itself.</p>\n<p>{% highlight javascript %}\nclass Counter {\n//...\nadd() {\nthis.count++;\nthis::somePrivateMethod();\n}\n}</p>\n<p>function somePrivateMethod() {\nconsole.log('count updated', this.count);\n}\n{% endhighlight %}</p>\n<p>The magic here is <code>this::somePrivateMethod()</code>, which actually compiles down to <code>somePrivateMethod.call(this)</code>. If you are unfamiliar with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" title=\"Mozilla Developer Network - Function Call documentation\"><code>Function.prototype.call</code></a>, it calls the function and uses the first argument as the function's <code>this</code>.</p>\n<p>When we do <code>this::somePrivateMethod</code>, that takes the left hand argument and uses it for the parameter to <code>call</code>, so we end up with <code>somePrivateMethod.call(this)</code>.</p>\n<h3>Function-bind compiled</h3>\n<p>Using the <a href=\"https://babeljs.io/repl/#?experimental=true&evaluate=true&loose=true&spec=false&code=class%20Counter%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.count%20%3D%200%3B%0A%20%20%7D%0A%20%20add()%20%7B%0A%20%20%20%20this.count%2B%2B%3B%0A%20%20%20%20this%3A%3AsomePrivateMethod()%3B%0A%20%20%7D%0A%7D%0A%0Afunction%20privateMethod()%20%7B%0A%20%20console.log('count%20updated'%2C%20this.count)%3B%0A%7D\" target=\"_blank\" title=\"Babel REPL\">Babel REPL</a>, we can see this is true</p>\n<p>{% highlight javascript %}\nfunction _classCallCheck(instance, constructor) { ... }\nvar Counter = (function () {\nfunction Counter() {\n_classCallCheck(this, Counter);\nthis.count = 0;\n}</p>\n<p>  Counter.prototype.add = function add() {\nthis.count++;\nsomePrivateMethod.call(this);\n};</p>\n<p>  return Counter;\n})();</p>\n<p>function privateMethod() {\nconsole.log('count updated', this.count);\n}\n{% endhighlight %}</p>\n<p>Do note that ES7 capabilities are considered experimental at this time. Babel does not support using these in production yet.</p>","frontmatter":{"date":"2015-12-24 10:30:00","permalink":"/blog/exploring-es2015-private-class-methods-babel","title":"Exploring ES2015 - Private class methods with Babel"}}},"pageContext":{}}