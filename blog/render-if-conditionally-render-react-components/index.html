<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/app.319712d3e7fffa8163a7.css">code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.0.53"/><style data-emotion-css=""></style><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link as="script" rel="preload" href="/component---src-page-components-posts-post-js-0ce19c8df93989175e36.js"/><link as="script" rel="preload" href="/app-5f862d30c389b7e33f69.js"/><link as="script" rel="preload" href="/webpack-runtime-aec8d6ecca58d5cf01b4.js"/><link rel="preload" href="/static/d/255/path---blog-render-if-conditionally-render-react-components-eb-5-ffd-kY9Tigg2Vv33Aac0pDPZqBtFLqY.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div>Hello World<div><p>One of the first questions nearly everyone asks when they first start using React is "How do I conditionally render an element?". Any time a React element is part of a <code>render</code> body, it will be evaluated and rendered. Unlike Angular's <code>ng-if</code>, there is no attribute that can prevent an element from being rendered.</p>
<p>This is where <a href="https://github.com/ajwhite/render-if" target="_blank" title="RenderIf - Conditionally render React components">render-if</a> comes in.</p>
<h2>As an in-line condition</h2>
<p>{% highlight js %}
render() {
return (
{renderIf(1 + 2 === 3)(
<span>Hello World!</span>
)}
);
}
{% endhighlight %}</p>
<h2>As a named conditional function</h2>
<p>{% highlight js %}
render() {
const ifUniverseIsWorking = renderIf(1 + 2 === 3)
return (
{ifUniverseIsWorking(
<span>Everything is okay in the world</span>
)}
);
}
{% endhighlight %}</p>
<h2>As a composed conditional function</h2>
<p>{% highlight js %}
const ifEven = count => renderIf(count % 2 === 0);
const ifOdd = count => renderIf(count % 2 !== 0);
render() {
return (
{ifEven(this.props.count)(
<span>{this.props.count} is an even number!</span>
)}
{ifOdd(this.props.count)(
<span>{this.props.count} is an odd number!</span>
)}
);
}
{% endhighlight %}</p>
<h2>Conditionals don't work so well in React</h2>
<p>If you're reading this, good chances are that you already know the problem conditional UI components presents in React. I've generally seen three approaches.</p>
<ol>
<li>Lazy evaluation</li>
<li>Variable assignment</li>
<li>Function encapsulation</li>
</ol>
<h3>Lazy evaluation</h3>
<p>In Javascript, and many other languages, boolean expressions are evaluated from left to right until the expression can be determined and it won't go farther than it needs to. This is also known as <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" target="_blank" title="Short Circuit evaluation">short circuit evaluation</a>.</p>
<p>When <code>if (true || false)</code> is evaluated, it knows that <em>either</em> of the conditions are needed to satisfy the expression. When reading from left to right, <code>true</code> is the first evaluation. Since this is an <code>OR</code> expression, we need not to go farther.</p>
<p>In the case of <code>if (false &#x26;&#x26; true)</code>, the same idea applies. Since this is an <code>AND</code> expression, both conditions must be <code>true</code>. The first value evaluated is <code>false</code>, so we know that the following value won't change the outcome of the expression and is not evaluated.</p>
<p>Lastly, in the case of javascript, when you have an expression <code>var result = true &#x26;&#x26; 'foobar'</code>, you actually don't get a boolean back, you get the final value in the expression, <code>foobar</code>. This allows us to use the second value in our expression as the "return" object, which we can take advantage of in JSX:</p>
<p>{% highlight js %}
class MyComponent extends Component {
render() {
return (
<div>
{1 + 2 == 3 &#x26;&#x26; <span>I show up only when the left hand is true</span>}
</div>
);
}
}
{% endhighlight %}</p>
<h3>The variable</h3>
<p>This is a pretty common one. A variable is used to hold the element, and the variable assignment is based on a condition. You'll see this most frequently when you're dealing with an <code>if-else</code> scenario.</p>
<p>{% highlight js %}
class MyComponent extends Component {
render() {
var component;
if (1 + 2 === 3) {
component = <span>I show up only when this condition is true</span>
} else {
component = <span>I show up when the condition is false</span>
}
return (
{component}
);
}
}
{% endhighlight %}</p>
<h3>The function</h3>
<p>This is also a common one. You'll see this when there's a lot of conditional UI components that would bloat the <code>render</code> function, or if the logic is complex and is better contained separately.</p>
<p>{% highlight js %}
class MyComponent extends Component {
render() {
return (
{this.renderConditionalComponent()}
)
}
renderConditionalComponent() {
if (1 + 2 === 3) {
return <span>I only show up when this condition is true</span>
} else {
return <span>I only show up when this condition is false</span>
}
}
}
{% endhighlight %}</p>
<p>All of these are valid approaches to conditional UI components. Each one can be more beneficial than the other depending on the scenario.</p>
<h2>RenderIf</h2>
<p><code>render-if</code> takes a different approach. A lot of people when they first start off might be tempted to treat JSX like liquid templates control flow tags:</p>
<p>{% highlight js %}
render() {
return (
{if (1 + 2 === 3)}
<span>This doesn't work</span>
{endif}
);
}
{% endhighlight %}</p>
<p>Unfortunately, or rather fortunately, you've found that it doesn't work this way. With <code>render-if</code>, we can achieve a syntatically similar and valid approach.</p>
<p>{% highlight js %}
render() {
return (
{renderIf(1 + 2 === 3)(
<span>This works!</span>
)}
);
}
{% endhighlight %}</p>
<p><code>render-if</code> is a curry function. Meaning it's a function that returns a function based on the context provided by the original function call. <code>renderIf(predicate)(element)</code>. If the <code>predicate</code> is <code>true</code>, the <code>element</code> passed into the second call is returned. If the <code>predicate</code> is <code>false</code>, the <code>element</code> is not returned.</p>
<p>It's as simple as that.</p>
<p>{% highlight js %}
const renderIf = predicate => element => predicate &#x26;&#x26; element;
{% endhighlight %}</p>
<p>This affords us the ability to do two things. As seen in the example above, we can structure our <code>renderIf</code> very similar to an <code>if</code> statement, just without curly brackets <code>{ }</code>. It also allows us to compose named conditional render functions.</p>
<h3>Conditions as functions</h3>
<p>Having a curry function allows us to compose functions representing our conditions. It's easiest to understand this by looking at an example:</p>
<p>{% highlight js %}
render() {
const ifUniverseIsWorking = renderIf(1 + 2 === 3);
const ifUniverseIsNotWorking = renderIf(1 + 2 !== 3);</p>
<p>  return (
<div>
{ifUniverseIsWorking(
<span>All is well in the world</span>
)}
{ifUniverseIsNotWorking(
<span>Something is terribly wrong</span>
)}
</div>
);
}
{% endhighlight %}</p>
<p>This is where things get a bit nicer and fall a bit closer to the React tree. We're used to being able to easily render collections, like <code>{collection.map((value, index) => &#x3C;span key={index}>{value}&#x3C;/span>)}</code>. However we don't have a nice way to do this with conditions. Until now.</p>
<h2>Putting it all together</h2>
<p>Let's take a look at what a real React component might look like with <code>render-if</code>.</p>
<p>{% highlight js %}
class OddsEvens extends Component {
constructor(props) {
super(props);
this.state = {
count: 1
};
}
increment() {
this.state.count++;
this.setState(this.state);
}
render() {
const isEven = renderIf(this.state.count % 2 === 0)
const isOdd = renderIf(this.state.count % 2 !== 0)
return (
<div>
<div>
<span>Count: {this.state.count}</span>
{isEven(
<span>It's even</span>
)}
{isOdd(
<span>It's odd</span>
)}
</div>
&#x3C;button onClick={() => this.increment()}>Increment</button>
</div>
);
}
}
{% endhighlight %}</p>
<p>It's also very composable. Say we don't want to put <code>const</code> in the <code>render</code> method, but rather define it outside the class and call it as a function providing the value to evaluate in the condition.</p>
<p>{% highlight js %}
const isEven = count => renderIf(count % 2 === 0)
const isOdd = count => renderIf(count % 2 !== 0)</p>
<p>class OddsEvens extends Component {
constructor(props) {
super(props);
this.state = {
count: 1
};
}
increment() {
this.state.count++;
this.setState(this.state);
}
render() {
return (
<div>
<div>
<span>Count: {this.state.count}</span>
{isEven(this.state.count)(
<span>It's even</span>
)}
{isOdd(this.state.count)(
<span>It's odd</span>
)}
</div>
&#x3C;button onClick={() => this.increment()}>Increment</button>
</div>
);
}
}
{% endhighlight %}</p>
<h2>You don't <em>really</em> need this</h2>
<p>In the end, this is handy, but all we're really doing is creating a function that returns something if one of the values is true.</p>
<p>Let's lastly look at how we might do this with the language itself by creating a curried function that behaves as an <code>if-else</code></p>
<p>{% highlight js %}
const ifEven = number => element => elseElement => {
if (number % 2 === 0) return element;
return elseElement;
}</p>
<p>class MyComponent extends Component {
render() {
return (
{ifEven(this.props.count)(
<span>{this.props.count} is even</span>
)(
<span>{this.props.count} is odd</span>
)}
);
}
}
{% endhighlight %}</p>
<p>You can find this project <a href="https://github.com/ajwhite/render-if" target="_blank" title="RenderIf - Conditionally render React components">on Github</a>.</p></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-page-components-posts-post-js","jsonName":"blog-render-if-conditionally-render-react-components-eb5","path":"/blog/render-if-conditionally-render-react-components"};window.dataPath="255/path---blog-render-if-conditionally-render-react-components-eb-5-ffd-kY9Tigg2Vv33Aac0pDPZqBtFLqY";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app.319712d3e7fffa8163a7.css","/app-5f862d30c389b7e33f69.js"],"component---src-page-components-posts-post-js":["/component---src-page-components-posts-post-js-0ce19c8df93989175e36.js"],"component---src-pages-404-js":["/component---src-pages-404-js.a82bc48cfa31deea5b5f.css","/component---src-pages-404-js-1d8ef4bfd6950bd882e3.js"],"component---src-pages-index-js":["/component---src-pages-index-js.a82bc48cfa31deea5b5f.css","/component---src-pages-index-js-6623fc1c7954d7e08157.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js.a82bc48cfa31deea5b5f.css","/component---src-pages-page-2-js-8b55a05b5c2fbefdcf8b.js"]};/*]]>*/</script><script src="/webpack-runtime-aec8d6ecca58d5cf01b4.js" async=""></script><script src="/app-5f862d30c389b7e33f69.js" async=""></script><script src="/component---src-page-components-posts-post-js-0ce19c8df93989175e36.js" async=""></script></body></html>